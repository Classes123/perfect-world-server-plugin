# Написание плагинов для сервера

Со временем у серверовладельца может появиться потребность в расширении функционала его сервера, однако отсутствие исходников / API может звучать как приговор, хотя это далеко не так.

> [!IMPORTANT]
> Сразу скажу, что это не гайд по реверсу кода или его написанию на C / C++, а демонстрация пары техник, которые позволяют расширять функционал сервера без рекомпиляции / модификации бинаря.

Затрагивание последнее, я заметил, что в сообществе отдельная любовь к модификации бинаря, и, отчасти, цель - показать, что без этого можно обойтись.

Чтобы базово продемонстрировать процесс написания плагина, давайте придумаем какое-нибудь простенькое ТЗ: 
```
Вывести сообщение в мировой чат при успешном открытии определенного сундука.
```

Проанализировав его, можно сделать вывод, что существует как минимум две функции, одну из которых нам нужно вызвать, а вызов другой отследить.

Таким образом, здесь будут рассматриваться две техники для решения подобных задач: 
- вызов существующей незашаренной функции
- отслеживание (хук) существующей функции

И да, нам понядобится IDA / Ghidra и окружение для компиляции на C++ (его можно взять из Dockerfile, **но для вашего сервера лучше использовать его собственное**).

> [!IMPORTANT]
> В процессе разработки рекомендую выполнить две вещи, они значительно ускорят процесс:
> - Проверьте, а нет ли исходного кода в открытом доступе? Полезен будет любой, даже устаревший.
> - При загрузке бинаря в дизассемблер, не ленитесь грузить дебаг символы.

Также уточню, что все манипуляции будут происходить на Linux, на других ОС свои нюансы.
В результате мы должны получить модуль, где точки входа / выхода - конструктор / деструктор.

Теперь перейдем непосредственно к написанию плагина.

## Вызов функции

Начнем с самого простого, с вызова функции. 
Для этого нам необходимо узнать её адрес.

С помощью IDA я нашел функцию в `gs`, находящуюся по адресу `0x84BFBCE`.
```cpp
bool __cdecl GMSV::SystemChatMsg(const void *msg, size_t size, char channel, const void *data, size_t dsize);
```

К сожалению адрес, который мы вытащили, наверняка съедет при запуске `gs`. 

Что же делать в такой ситуации?
Есть несколько способов, например, мы можем начать считать относительно нулевого адреса в выделенной памяти, а адрес выше использовать как оффсет.
Однако такой способ не очень надежный, поскольку при рекомпиляции `gs` этот адрес с большой вероятностью поменяется.
Более надежный способ - использовать сигнатуры.

Сигнатура функции - уникальная последовательность байтов, генерируемая от начала функции.
При использовании сигнатур отпадает потребность ручного поиска адреса, а если дополнительно в них использовать вайлдкарды, то наверняка сигнатура останется неизменной при рекомпиляции вплоть до модификации функции.

Конечно же, вручную мы этого делать не будем, для IDA есть плагины SigMaker [7](https://github.com/ajkhoury/SigMaker-x64), [8-9](https://github.com/A200K/IDA-Pro-SigMaker).

Генератор мне выдал такое:
```
55 89 E5 53 83 EC 54 8B 45 ? 88 45 ? 83 EC 0C 8D 45
```

Теперь нам необходимо применить её в коде, с этим нам поможет библиотека [libsigscan](https://github.com/8dcc/libsigscan).

Сделаем объявления:
```cpp
typedef bool (*SystemChatMsg_t)(const void *msg, size_t size, char channel, const void *data, size_t dsize);    // 1. Прототип функции
SystemChatMsg_t g_ptrSystemChatMsg;                                                                             // 2. Указатель на оригинальную функцию
bool SystemChatMsg(const void *msg, size_t size, char channel, const void *data = nullptr, size_t dsize = 0);   // 3. Обертка для удобства (можно и без нее)
```

Чтобы сразу проверить адрес на валидность, реализуем код с `assert` (P.S. `assert` следует применять только для `debug` билдов):
```cpp
inline void *GetFuncPtr(const char *signature)
{
    void *ptrFunc = sigscan(signature);
    assert(ptrFunc != nullptr);
    return ptrFunc;
}

inline void *GetFuncPtr(const char *module, const char *signature)
{
    void *ptrFunc = sigscan_module(module, signature);
    assert(ptrFunc != nullptr);
    return ptrFunc;
}
```

Извлечем адрес в конструкторе, указав модуль и сигнатуру:
```cpp
__attribute__ ((constructor)) void init()
{
    // GMSV::SystemChatMsg (gs + 0x84BFBCE)
    g_ptrSystemChatMsg = reinterpret_cast<SystemChatMsg_t>(
        GetFuncPtr(
            "gs",                                                       // Модуль 
            "55 89 E5 53 83 EC 54 8B 45 ? 88 45 ? 83 EC 0C 8D 45"       // Сигнатура
        )
    );
}
```

Для удобства, реализуем обертку вокруг указателя:
```cpp
bool SystemChatMsg(const void *msg, size_t size, char channel, const void *data, size_t dsize)
{
    return g_ptrSystemChatMsg(msg, size, channel, data, dsize);
}
```

Готово, теперь мы можем отправлять сообщения в системный чат.

> [!NOTE]
> В коде используется нумерация чат-каналов, которая была дернута из старого исходника и может быть некорректной для ваших нужд.
> Также она помещена в далеко не полный SDK, но это уже вопрос организации окружения.

## Отслеживание вызова функции (Хук)

Здесь будет посложнее. Как и в предыдущей технике, нам сначала нужно найти адрес функции.

Исходя из логики, что открытие сундука можно считать успешным после получения предмета, я нашел функцию доставки в `libtask.so`:
```cpp
void __cdecl _DeliverItem(TaskInterface *pTask, unsigned int ulTask, const ITEM_WANTED *const wi, unsigned int ulMulti);
```

Получаем сигнатуру:
```
55 89 E5 53 81 EC 24 04 00 00 E8 ? ? ? ? 5B 81 C3 2B 72 03 00
```

Начнем внедрять это в код.

Без прелюдий, такая техника называется Detour. \
Её особенность заключается в том, что в начале функции есть неоперабельные байты, которых хватает, чтобы перенаправить вызов.
Патч осуществляется в виртуальной памяти, а поможет нам с этим [libdetour](https://github.com/8dcc/libdetour).

> [!IMPORTANT]
> Если в предыдущей технике мы могли не учитывать все нюансы, то здесь необходимо учитывать все.

В нашем случае все тривиально.

Начинаем с определений:
```cpp
LIBDETOUR_DECL_TYPE(void, DeliverItem, void *, unsigned int, const void *, unsigned int);            // 1. Прототип функции (макрос уже реализован в libdetour для удобства)
libdetour_DeliverItem_t g_ptrDeliverItem;                                                            // 2. Указатель на оригинальную функцию
void Hook_DeliverItem(void *pTask, unsigned int ulTask, const void *wi, unsigned int ulMulti);       // 3. "коллбэк"
libdetour_ctx_t g_ctxDeliverItem;                                                                    // 4. Контекст хука
```

Извлечем адрес функции, проинициализируем и активируем хук:
```cpp
__attribute__ ((constructor)) void init()
{
    // _DeliverItem (libtask.so + 0x26A16)
    g_ptrDeliverItem = reinterpret_cast<libdetour_DeliverItem_t>(
        GetFuncPtr(
            "libtask.so",                                                       // Модуль
            "55 89 E5 53 81 EC 24 04 00 00 E8 ? ? ? ? 5B 81 C3 2B 72 03 00"     // Сигнатура
        )
    );

    // Инициализируем хук
    libdetour_init(
        &g_ctxDeliverItem,                                                      // Контекст хука
        reinterpret_cast<void *>(g_ptrDeliverItem),                             // Указатель на оригинальную функцию
        reinterpret_cast<void *>(&Hook_DeliverItem)                             // Указатель на нашу функцию (коллбэк)
    );
    
    // Активируем хук
    libdetour_add(&g_ctxDeliverItem);
}
```

Создадим коллбэк, сделаем фильтр по квесту, который вызывает сундук, и напишем сообщение:
```cpp
void Hook_DeliverItem(void *pTask, unsigned int ulTask, const void *wi, unsigned int ulMulti)
{
    // Вызовем сначала оригинал, он должен быть в приоретете если у нас что-то пойдет не так
    LIBDETOUR_ORIG_CALL(&g_ctxDeliverItem, DeliverItem, pTask, ulTask, wi, ulMulti);

    // Сундук вызывает квест с ID == 43562
    if (ulTask == 43562)
    {
        // Отправляем сообщение в системный чат
        char16_t msg[] = u"^FFFF00Кто-то открыл cундук!";
        SystemChatMsg(msg, sizeof(msg), GMSV::CHAT_CHANNEL_BROADCAST);
    }
}
```

Также, отключим хук, если наш плагин выгрузится:
```cpp
__attribute__ ((destructor)) void fini()
{
    // Если хук активен
    if (g_ctxDeliverItem.detoured)
    {
        // Отключим хук
        libdetour_del(&g_ctxDeliverItem);
    }
}
```

Плагин готов. Собираем и идем запускать.

## Запуск плагина

Мне на ум проще `LD_PRELOAD` ничего не приходит, из минусов только то, что некоторые функции из других модулей / библиотек, которые аналогично загружены через `LD_PRELOAD`, могут не патчиться.

На всякий случай, если кто-то не знает как использовать `LD_PRELOAD`:
```bash
LD_PRELOAD="./plugin.so" ./gs <...>
```

Зайдем на сервер и откроем сундук: \
![image](https://github.com/user-attachments/assets/9874ddf4-939a-4bc2-8503-25da28986d5f)

Все работает так, как и задумывалось.

## Миниитог

Ну вот, собственно, две основные техники, которые вам помогут в написании плагинов. \
Таким способом можно реализовывать кастомные фичи, в том числе и редактировать скиллы, переменные и тд, не имея исходного кода и не внося изменений в бинарь.

Код и окружение для сборки доступны в репозитории.
